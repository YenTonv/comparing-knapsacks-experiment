package knapsacks;

import java.io.File;
import java.io.FileNotFoundException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Scanner;

public class Knapsack {
    // the capacity of this knapsack
    private int capacity;
    // the knapsack label
    private String name;
    // tracker property for current weight of added items
    private int weight = 0;
    // tracker property for current value of added items
    private double value = 0.0;

    // list of available items that could go in this knapsack
    List<Item> availableItems;

    // list of optimal items generated by one of the optimization algorithms
    List<Item> optimalItems;

    // constructor specifying name and capacity with empty item lists
    public Knapsack(String name, int capacity) {
        this.capacity = capacity;
        this.name = name;

        availableItems = new ArrayList<>();
        optimalItems = new ArrayList<>();
    }

    // constructor that builds the knapsack from a specification file
    public Knapsack(String fileName) throws FileNotFoundException {
        Scanner in = new Scanner(new File(fileName));
        String[] characteristics;
        String[] weights;
        String[] values;
        characteristics = in.nextLine().split(",");

        this.name = characteristics[0];
        this.capacity = Integer.parseInt(characteristics[1]);
        optimalItems = new ArrayList<>();

        values = in.nextLine().split(",");
        weights = in.nextLine().split(",");

        this.availableItems = new ArrayList<>();

        for (int i = 0; i < weights.length; i++) {
            this.availableItems.add(new Item("Item " + i, Integer.parseInt(weights[i]), Integer.parseInt(values[i])));
        }
    }

    //default constructor
    public Knapsack() {
        this("0",0);
    }

    /**
     * Adds an item to the available list.
     * @param item is an Item object to add to the available list.
     */
    public void addAvailableItem(Item item) {
        availableItems.add(item);
    }

    /**
     * Adds an item to the optimal items list.
     * @param item is the Item to mark as optimal.
     */
    public void addOptimalItem(Item item) {
        optimalItems.add(item);
        weight += item.getWeight();
        value += item.getTotalValue();
    }

    /**
     * Replace the entire optimal items list.
     * @param newOptimalItems is the new optimal item list.
     * @param optimalWeight is the new optimal weight.
     * @param optimalValue is the new optimal value.
     */
    public void replaceOptimalItems(List<Item> newOptimalItems, int optimalWeight, double optimalValue) {
        optimalItems = newOptimalItems;
        weight = optimalWeight;
        value = optimalValue;
    }

    /**
     * Add part of an item to the optimal items list for fractional knapsacks.
     * @param item is the Item object to split and add part of to the list.
     * @param quantity is how much of the item to use.
     */
    public void addPartialItem(Item item, int quantity) {
        double partialValue = quantity * item.getValuePerUnit();
        Item partialItem = new Item(quantity + " of " + item.getName(), quantity, partialValue);
        optimalItems.add(partialItem);
        weight += partialItem.getWeight();
        value += partialItem.getTotalValue();
    }

    /**
     * Returns the list of available items that could go into this knapsack.
     * @return is the List of available items.
     */
    public List<Item> getAvailableItems() {
        return availableItems;
    }

    public List<Item> getOptimalItems() {
        return optimalItems;
    }

    /**
     * Clears the available item list.
     */
    public void resetAvailableItemList() {
        availableItems = new ArrayList<>();
    }

    /**
     * Prints out the characteristics and contents of this knapsack.
     */
    public void displayKnapsack() {
        System.out.println("Knapsack " + this.name + ":");
        System.out.println("Capacity: " + this.capacity);
        System.out.println();
        System.out.println("Optimal Items:");
        if (optimalItems.size() > 0) {
            for (Item i : optimalItems) {
                System.out.println(i);
            }
        } else {
            System.out.println("<Not yet calculated>");
        }
        System.out.println();
        System.out.println("Available Items: W | V");
        if (availableItems != null) {
            for (Item i : availableItems) {
                System.out.println(i);
            }
        }
    }

    /**
     * Gets the capacity of this knapsack.
     * @return is the capacity of the knapsack.
     */
    public int getCapacity() {
        return capacity;
    }

    /**
     * Sets the capacity of this knapsack.
     * @param capacity is the capacity of the knapsack.
     */
    public void setCapacity(int capacity) {
        this.capacity = capacity;
    }

    /**
     * Gets the name of this knapsack.
     * @return is the current name of the knapsack.
     */
    public String getName() {
        return name;
    }

    /**
     * Sets the name of this knapsack.
     * @param name is the new name to set.
     */
    public void setName(String name) {
        this.name = name;
    }

    /**
     * Generates a deep copy of this Knapsack.
     * @return is the new copy of the Knapsack.
     */
    public Knapsack copyOf() {
        Knapsack k = new Knapsack(this.name, this.capacity);

        for (Item i : availableItems) {
            k.addAvailableItem(new Item(i.getName(), i.getWeight(), i.getTotalValue()));
        }

        for (Item i : optimalItems) {
            k.addOptimalItem(new Item(i.getName(), i.getWeight(), i.getTotalValue()));
        }

        return k;
    } // theoretical efficiency: O(n + m)

    /**
     * Recalculates the weight of the bag based on the current list of optimal items.
     *
     * @return is the current weight of the bag.
     */
    public int calculateCurrentWeight() {
        int weight = 0;

        for (Item i : optimalItems) {
            weight += i.getWeight();
        }

        this.weight = weight;

        return weight;
    } // theoretical efficiency: O(n)

    /**
     * Recalculates the value of the bag based on the current list of optimal items.
     *
     * @return is the current value of the contents of the bag.
     */
    public double calculateCurrentValue() {
        double value = 0.0;

        for (Item i : optimalItems) {
            value += i.getTotalValue();
        }

        this.value = value;

        return value;
    } // theoretical efficiency: O(n)

    /**
     * Returns the current weight of the bag without recalculating it.
     *
     * @return is the weight of the bag.
     */
    public int getCurrentWeight() {
        return weight;
    } // theoretical efficiency: O(1)

    /**
     * Returns the current value of the bag without recalculating it.
     *
     * @return is the value of the bag.
     */
    public double getCurrentValue() {
        return value;
    } // theoretical efficiency: O(1)

    public void resetKnapsack(){
        availableItems.clear();
        for(Item x : optimalItems){
            availableItems.add(x);
        }
        optimalItems.clear();
        Collections.shuffle(availableItems);
    } // theoretical efficiency: O(n)
}
